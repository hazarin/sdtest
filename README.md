# Тест sibdev
## Зависимости
python3.6, sqlite 

## Разворачивание и запуск проекта
Клонировать репозиторий проекта локально  
`git clone https://github.com/hazarin/sdtest.git` 

### Без docker
Создать и активировать новую виртуальную среду 
```
cd sdtest
python -m venv venv
source ./venv/bin/activate
```

Выполнить установку зависимостей проекта  
`pip install -r requirements.txt`  

Выполнить миграции и загрузку фикстур  
`python manage.py migrate`  
`python manage.py loaddata.shedule.json` - расписание рассылки для Django-q  
`python manage.py load_participants participants.jsonl` - предпочтения и участники  

Запустить сервер разработки и кластер очередей django-q  
`python manage.py qcluster & python manage.py runserver 127.0.0.1:8000`

### Запуск проекта с использованием docker
```
cd sdtest
docker-compose up -d
```

После этого проект доступен по адресу: http://localhost:8000  

Администратор:  
login: *admin@admin.com*  
password: *admin*  

### Краткое описание
Для реализации менеджмента пользователей использованы библиотеки *django-rest-auth*+*django-allauth*  
Документация RESTApi - *drf-yasg*. Использование DRF Browsable API покеазалось неудобным  
Для дополнительного контроля рассылок используется *django-mail*. Для запуска задач рассылки по расписанию используется
*django-q*. Т.к. в качестве движка БД используется SQLite возможны исключения при записи в БД, для решения достаточно
использовать MYSQL или Postgre в качестве сервера БД

Сериализация предпочтений реализована с помощью Custom Field с целью приблизить формат результатов к представленному в 
фикстурах.
Для подстчета рейтинга совместимости используется RAW SQL т. к. мне показалось, что использование ORM будет менее 
прозрачно и количество кода сильно возрастет. Расчет производится следующим образом:  
Производится выборка пользователей с пересечениями предпочтений с предпочтениями текущего пользователя, предпочтения 
разных знаков считаются непересекающимися, в выборке производится рассчет совпедения предпочтений в процентах. Далее
рассчитывается среднее арифметическое процента совместимости по всем пересекающимся предпочтениям. Выборка 
упорядочивается сначала по количеству пересечений и далее по среднему проценту совместимости. Вся логика в
`api.models.ParticipantManager.compatible`, avg в запросе не использовал чтобы было яснее.
Как это покрыть тестами - реально не очень представляю.

*users* - приложение реализующее кастомную модель пользователя и работу с ней  
*api* - основное приложение для работы с приоритетами

